* sources of inconsistency
** type in type
** no datatype positivity check
* implementation details
** conversion and first-order unfification as same algorith with extra argument
*** different in variable and extend context cases
* todos
** whnf/conversion/typing rules for Types (Pi, Type)
*** universe levels?
* examples
** checking not with Church boolean in core calculus
** checking Nat with identity view in core calculus
* another way of thinking of our contribution
** type and coverage checking for pattern synonyms
*** or elaborating pattern synonyms (views?)
* uses
** pattern matching for refactoring
** pattern matching for computational types
** pattern matching for computational descriptions
** pretty printing up to whnf
* unification
** ρ expansion similar to δ expansion
*** try unexpanded, if it fails try to expand
